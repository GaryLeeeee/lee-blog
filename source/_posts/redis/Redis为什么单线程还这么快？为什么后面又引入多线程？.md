---
title: Redis为什么单线程还这么快？为什么后面又引入多线程？
date: 2023-11-07 19:10:59
tags:
categories: [Redis]
---

## 一、Redis为什么单线程还这么快？
Redis为什么这么快？具体可参考文章[《Redis为什么这么快？》](https://garyleeeee.github.io/2023/08/23/redis-wei-shi-me-zhe-me-kuai/)

我们可能会有疑问：**单线程不就只能监听单个连接了吗？为什么还能这么快？**

事实上，Redis是通过**IO多路复用**来监听来自客户端的多个连接的（即监听多个socket），它会将需要用到的事件及类型注册到内核中并监听每个事件是否发生。这样做的好处是：不需要创建多余的线程，只需要用单线程就能监听客户端的多个连接，降低了资源的消耗。

**文件事件处理器**主要包含4个部分：
* 多个socket（客户端连接）
* IO多路复用程序（用来连接多个客户端）
* 文件事件分派器（将socket关联到对应的事件处理器）
* 事件处理器（命令请求处理器、命令回复处理器、连接应答处理器）

![](/images/redis/Redis线程模型.png)

## 二、为什么Redis 6.0引入了多线程？
Redis 6.0引入了多线程，但只是网络IO层面的多线程，而底层数据读写仍然是单线程处理的。

**为什么Redis 6.0要引入多线程呢？**：因为Redis的瓶颈主要出现在内存和网络，如果流量过于大了，网络IO也可能会是一个问题，所以引入了多线程来减少网络IO等待造成的影响，从而充分利用CPU的多核优势。

## 三、Q&A
### 1、为什么Redis是单线程的？
为什么Redis是单线程的，主要有以下原因：
* 减少线程切换带来的性能损耗
* 避免死锁

### 2、Redis完全是单线程的吗？
Redis也不完全是单线程的，只是说执行命令的主线程是单线程，但其实还有一些后台线程用于执行一些耗时操作：
* 通过`bio_close_file`后台线程来释放AOF/RDB等过程中产生的临时文件资源
* 通过`bio_aof_fsync`后台线程调用`fsync`函数将系统内核缓冲区还未同步到磁盘的数据强制刷到磁盘（AOP文件）
* 通过`bio_lazy_free`后台线程释放大对象（已删除）占用的内存空间