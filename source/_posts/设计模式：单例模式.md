---
title: 设计模式：单例模式
date: 2021-12-12 23:12:32
tags: [设计模式,单例模式]
categories: [设计模式,单例模式]
---

# 设计模式：单例模式
## 定义
**单例模式**：一个类只允许创建一个对象(或者叫实例)，那么这个类就是一个单例类，这种设计模式就叫作`单例设计模式`

## 实现(例子：ID生成器)
### 饿汉式
* **定义**：通过静态变量在类加载的时候就创建并初始化好instance
* **优点**：线程安全(类加载初始化)
* **缺点**：不支持延迟加载(需要使用时才初始化)
* **总结**：如果初始化耗时长，推荐在程序启动的时候会就初始化好(而不是在使用时才初始化，会影响性能)，同时程序启动的时候还能暴露出资源可能不够的错误(而不是在使用时才报错，会影响系统可用性)
* **代码示例**：
```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    //静态实例创建并初始化好
    private static final IdGenerator instance = new IdGenerator();
    //private的构造方法
    private IdGenerator(){}
    //public的get方法
    public static IdGenerator getInstance() {
        return instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

### 懒汉式
* **定义**：在需要使用的时候才初始化
* **优点**：支持延迟加载(需要使用时才初始化)
* **缺点**：`getInstance()`方法加了`synchronized`关键字，导致这个函数的病发度很低(不适合频繁调用的场景)
* **总结**：可以延迟加载，但如果频繁调用，会导致性能瓶颈
* **代码示例**：
```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    //静态实例只声明不初始化
    private static IdGenerator instance;
    //private的构造方法
    private IdGenerator() {}
    //public的get方法
    public static synchronized IdGenerator getInstance() {
        if(instance == null) {
            instance = new IdGenerator();
        }
        return instance;
    }
    
    public long getId() {
        return id.incrementAndGet();
    }
}

```

### 双重检测
* **定义**：相比`懒汉式`，`instance`不为空的时候将不再会加锁(而是初始化的时候才会加锁)
* **优点**：`instance`为null的时候才会加锁(初始化)
* **缺点**：可能由于`指令重排序`导致new完`IdGenerator`之后，赋值给`instance`之后还没来得及初始化(new了但还没执行构造函数代码，这时候其他线程拿到的instance就不是null了)
* **总结**：判断`instance`为空才加锁，同时还可以给`instance`加`volatile`关键字(防止`指令重排序`)
* **代码示例**：
```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    //静态实例只声明不初始化
    private static IdGenerator instance;
    //private的构造方法
    private IdGenerator() {}
    public static IdGenerator getInstance() {
        if (instance == null) {
            //instance不为空才加锁
            synchronized (IdGenerator.class) {
                if (instance == null) {
                    instance = new IdGenerator();
                }
            }
        }
        return instance;
    }

    public long getId() {
        return id.incrementAndGet();
    }
}
```

### 静态内部类
* **定义**：利用Java的静态内部类，类似饿汉式的同时，又能做到延迟加载
* **原理**：初始化`IdGenerator`的时候并不会创建`SingletonHolder`（只会等调用`getInstance()`方法才会加载`SingletonHolder`并创建`instance`）。保证`instance`的唯一性、保证创建过程的线程安全性(JVM实现)
* **优点**：既保证了线程安全，又能做到延迟加载

```java
public class IdGenerator {
    private AtomicLong id = new AtomicLong(0);
    //private的构造方法
    private IdGenerator() {}
    
    //静态内部类
    private static class SingletonHolder {
        private static final IdGenerator instance = new IdGenerator();
    }
    
    public static IdGenerator getInstance() {
        return SingletonHolder.instance;
    }
    
    public long getId() {
        return id.incrementAndGet();
    }
}
```

### 枚举
* **定义**：基于枚举类型的单例实现(通过Java枚举类型本身的特性)
* **优点**：简单，保证了实例创建的线程安全性和实例的唯一性

```java
public enum IdGenertor {
    INSTANCE;
    private AtomicLong id = new AtomicLong(0);
    
    public long getId(){
        
    }
}
```


