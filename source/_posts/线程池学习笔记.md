---
title: 线程池学习笔记
date: 2021-07-28 13:08:21
tags: 学习笔记
categories: 并发
---

## 1.使用线程池的好处
* **降低资源消耗**
  `通过重复利用已创建的线程降低线程创建和销毁造成的消耗`
* **提高响应速度**
  `当任务到达时，任务可以不需要等到线程创建就能立即执行`
* **提高线程的可管理性**
  `线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控`
  
## 2.线程池使用场景
### 2.1 用和不用有什么区别
* 不使用线程池的情况下，任务顺序执行
* 使用线程池的情况下，任务同时执行

### 2.2 什么时候适合用
* 对于多个耗时且互不依赖的任务，可选择使用线程池
  > eg. 我们可以做家务的时候可以同时拖地和洗衣服(洗衣机)
* 对于多个耗时且依赖结果的任务，可选择使用线程池+CountDownLatch
  `CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行(阻塞)`
  > eg. 比如做一个项目需求，后端和前端同时开发(却不一定同时结束)，这时候快的一方必须等到慢的一方完成还可上线

## 3.如何使用线程池
一般是通过ThreadPoolExecutor的构造函数来创建线程池，然后提交任务给线程池执行即可。
```java
public class Test{
    public ThreadPoolExecutor(int corePoolSize, //线程池核心线程数
                              int maximumPoolSize, //线程池最大线程数
                              long keepAliveTime, //线程数大于核心线程数时，多余的空闲线程存活的最长时间
                              TimeUnit unit,
                              BlockingQueue<Runnable> workQueue,
                              ThreadFactory threadFactory,
                              RejectedExecutionHandler handler) {
        if (corePoolSize < 0 ||
            maximumPoolSize <= 0 ||
            maximumPoolSize < corePoolSize ||
            keepAliveTime < 0)
            throw new IllegalArgumentException();
        if (workQueue == null || threadFactory == null || handler == null)
            throw new NullPointerException();
        this.corePoolSize = corePoolSize;
        this.maximumPoolSize = maximumPoolSize;
        this.workQueue = workQueue;
        this.keepAliveTime = unit.toNanos(keepAliveTime);
        this.threadFactory = threadFactory;
        this.handler = handler;
    }
}
```
### 3.1 构造函数参数作用
|参数|作用|
|-------------|-------------|
|int corePoolSize|线程池核心线程数|
|int maximumPoolSize|线程池最大线程数||
|long keepAliveTime| 线程数大于核心线程数时，多余的空闲线程存活的最长时间|
|TimeUnit unit|时间单位||
|ThreadFactory threadFactory|线程工厂，用来创建线程，一般默认即可|
|RejectedExecutionHandler handler|拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务|

### 3.2 示例
```java

 public class Test{
    private static final int CORE_POOL_SIZE = 5;
    private static final int MAX_POOL_SIZE = 10;
    private static final int QUEUE_CAPACITY = 100;
    private static final long KEEP_ALIVE_TIME = 1L;
    //
    public static void main(String[] args){
        //创建线程池
      ThreadPoolExecutor executor = new ThreadPool(
              CORE_POOL_SIZE,
              MAX_POOL_SIZE,
              KEEP_ALIVE_TIME,
              TimeUnit.SECONDS,
              new ArrayBlockingQueue<>(QUEUE_CAPACITY),
              new ThreadPoolExecutor.CallerRunsPolicy()
      );
      //
      //执行任务
      for(int i=0;i<10;i++){
          executor.execute(
                  () -> {
                      try {
                          Thread.sleep(2000);
                      } catch (InterruptedException e){
                          e.printStackTrace();
                      }
                    System.out.println("Thread name:" + i);
                  }
          );
      }
    }
}
```


### 3.x 总结
* 

