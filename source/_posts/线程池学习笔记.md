---
title: 线程池学习笔记
date: 2021-07-28 13:08:21
tags: 学习笔记
categories: 并发
---

## 1.使用线程池的好处
* **降低资源消耗**
  `通过重复利用已创建的线程降低线程创建和销毁造成的消耗`
* **提高响应速度**
  `当任务到达时，任务可以不需要等到线程创建就能立即执行`
* **提高线程的可管理性**
  `线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控`
  
## 2.线程池使用场景
### 2.1 用和不用有什么区别
* 不使用线程池的情况下，任务顺序执行
* 使用线程池的情况下，任务同时执行

### 2.2 什么时候适合用
* 对于多个耗时且互不依赖的任务，可选择使用线程池
  > eg. 我们可以做家务的时候可以同时拖地和洗衣服(洗衣机)
* 对于多个耗时且依赖结果的任务，可选择使用线程池+CountDownLatch
  `CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行(阻塞)`
  > eg. 比如做一个项目需求，后端和前端同时开发(却不一定同时结束)，这时候快的一方必须等到慢的一方完成还可上线

## 3.如何使用线程池
一般是通过ThreadPoolExecutor的构造函数来创建线程池，然后提交任务给线程池执行即可。
![ThreadPoolExecutor构造函数](https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/ThreadPoolExecutor.png)
### 3.1 构造函数参数作用
|参数|作用|
|-------------|-------------|
|int corePoolSize|线程池核心线程数|
|int maximumPoolSize|线程池最大线程数||
|long keepAliveTime| 线程数大于核心线程数时，多余的空闲线程存活的最长时间|
|TimeUnit unit|时间单位||
|ThreadFactory threadFactory|线程工厂，用来创建线程，一般默认即可|
|RejectedExecutionHandler handler|拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务|

### 3.2 示例
new ThreadPoolExecutor().execute(()->{do sth.});
[点击跳转](https://github.com/GaryLeeeee/lee-code-repository)

### 3.3 execute、submit区别
* 传参
  * execute只能接受Runnable类型的任务
  * submit能接受Runnable和Callable类型的任务
  
* 返回值
  * execute没有返回值
  * submit有返回值(通过Future.get()获取)
  
* 异常
  * execute跟普通线程处理方式一致，通过try-catch捕获异常
  * submit会在call()抛出异常，所以需要Future.get()才能抛出异常


### 3.x 总结
* 

