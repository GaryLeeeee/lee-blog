---
title: 线程池学习笔记
date: 2021-07-28 13:08:21
tags: 学习笔记
categories: 并发
---

## 1.使用线程池的好处
* **降低资源消耗**
  `通过重复利用已创建的线程降低线程创建和销毁造成的消耗`
* **提高响应速度**
  `当任务到达时，任务可以不需要等到线程创建就能立即执行`
* **提高线程的可管理性**
  `线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配、调优和监控`
  
## 2.线程池使用场景
### 2.1 用和不用有什么区别
* 不使用线程池的情况下，任务顺序执行
* 使用线程池的情况下，任务同时执行

### 2.2 什么时候适合用
* 对于多个耗时且互不依赖的任务，可选择使用线程池
  > eg. 我们可以做家务的时候可以同时拖地和洗衣服(洗衣机)
* 对于多个耗时且依赖结果的任务，可选择使用线程池+CountDownLatch
  `CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行(阻塞)`
  > eg. 比如做一个项目需求，后端和前端同时开发(却不一定同时结束)，这时候快的一方必须等到慢的一方完成还可上线

## 3.如何使用线程池
一般是通过ThreadPoolExecutor的构造函数来创建线程池，然后提交任务给线程池执行即可。
![ThreadPoolExecutor构造函数](https://lee-blog-picture.oss-cn-shenzhen.aliyuncs.com/ThreadPoolExecutor.png)
### 3.1 构造函数参数作用
|参数|作用|
|-------------|-------------|
|int corePoolSize|线程池核心线程数|
|int maximumPoolSize|线程池最大线程数||
|long keepAliveTime| 线程数大于核心线程数时，多余的空闲线程存活的最长时间|
|TimeUnit unit|时间单位||
|ThreadFactory threadFactory|线程工厂，用来创建线程，一般默认即可|
|RejectedExecutionHandler handler|拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务|

### 3.2 示例
new ThreadPoolExecutor().execute(()->{do sth.});
[点击跳转](https://github.com/GaryLeeeee/lee-code-repository)

### 3.3 execute、submit区别
* 传参
  * execute只能接受Runnable类型的任务
  * submit能接受Runnable和Callable类型的任务
  
* 返回值
  * execute没有返回值
  * submit有返回值(通过Future.get()获取)
  
* 异常
  * execute跟普通线程处理方式一致，通过try-catch捕获异常
  * submit会在call()抛出异常，所以需要Future.get()才能抛出异常

### 3.4 建议不同类别的业务用不同的线程池
#### 3.4.1 为什么呢？
一般建议是不同的业务使用不同的线程池，配置线程池的时候根据当前业务的情况对当前线程池进行配置，因为不同的业务的并发以及对资源的使用情况都不同，重心优化系统性能瓶颈相关的业务
#### 3.4.2 错误案例
[《线程池运用不当的一次线上事故》](https://www.heapdump.cn/article/646639)

简单来说，就是线程池被父任务占满了，导致所有的子任务没有线程去执行(导致队列堆积)，而且父任务会阻塞住，造成死锁
![共用线程池死锁图示](https://a.perfma.net/img/646605)

## 4.正确配置线程池参数
* 如果我们设置的线程池数量太小，如果同一时间有大量任务需要处理，那么就可能会导致大量任务要在任务队列等待，导致OOM。这样的CPU并没有得到充分利用。
* 如果我们设置的线程池数量太大，大量线程可能会同时争取CPU资源，导致有大量的上下文切换，从而增加线程的执行时间，影响整体的执行效率

所以我们在设置线程池大小时有个公式
* **CPU密集型任务(N+1)** 这种任务消耗的主要是CPU资源，可以将线程数设置为N(CPU核心数)+1，比CPU核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其他原因导致的任务暂停而带来的的影响。一旦任务暂停，CPU就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用CPU的空闲时间。
* **I/O密集型任务(2N)** 这种任务引用起来，系统会用大部分的事件来处理I/O交互，而线程在处理I/O的时间段内不会占用CPU来处理，这时就可以将CPU交出给其它线程使用。因此在I/O密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是2N。

## 5.总结
* 建议不同场景使用不同的线程池，防止死锁
* 空间换时间
* 不允许使用Executors创建线程池，应该通过ThreadPoolExecutor去创建
* 不同线程池命不同的名(如pool-1-thread-n)，有利于定位问题
  * [示例](https://github.com/GaryLeeeee/lee-code-repository)



