---
title: k8s学习笔记
date: 2021-08-12 22:04:11
tags: 学习笔记
categories: k8s
---

## 容器技术概念入门篇
### 05 | 白话容器基础（一）：从进程说开去
* **容器其实是一种沙盒技术。** 顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这样，应用与应用之间，就因为有了`边界`而不至于相互干扰；而被装进集装箱的应用，也可以被方便地搬来搬去。
* 容器本身没有价值，有价值的是"**容器编排**"
* **镜像**。比如我们要做一个加法程序，由于计算机只认识0和1，所以无论用哪种语音编写这段代码，最后都需要翻译成`二进制文件`，才能在计算机操作系统跑起来。为了让这些代码正常运行，还需要提供`数据`，比如这个加法程序，将`数据`和代码本身的`二进制文件`，放在磁盘上，就是平常我们所说的程序，也叫代码的`可执行镜像`  
* **进程**。对于进程来说，它的`静态表现`就是程序，平常都安安静静地待在磁盘上；而一旦运行起来，它就变成了计算机里的数据和状态的综合，这就是它的`动态表现`。
  * 输入数据
  * 寄存器的值变化
  * 堆桟中的指令变化
  * 被打开的文件
  * 各种设备的状态信息变化  
* **容器技术的核心功能**，就是通过约束和修改进程的`动态表现`，从而为其创造出一个`边界`
  * `Ggroups技术`是用来制造约束的主要手段
  * `Namespace技术`则是用来修改进程视图的主要方法  
  
* 跟真实存在的`虚拟机`不同，在使用docker的时候并密友一个真正的"docker容器"运行在宿主机里面。docker项目帮助用户启动的还是原来的引用进程，只不过在创建这些进程时，docker为它们加上了各种各样的`Namespace`参数
  * 这时这些进程就会觉得自己是各自PID Namespace里的第1号进程
  * 只能看到各自Mount Namespace里挂载的目录和文件
  * 只能访问到各自Network Namespace里的网络设备
  * 彷佛运行在一个个"容器"里面，与世隔绝
    
* 小结
  * **程序**：静态状态是文件，动态状态是进程
  * `Cgroups`限制资源，`Namespace`隔离资源
  * **容器**：其实就是操作系统在启动进程时通过**设置**一些参数实现了**隔离**不相关资源后的一个特殊**进程**
    * 实际上没有一个真正的容器运行在宿主机里面(只是Namespace造成了这一个个进程的错觉)
    
### 06 | 白话容器基础（二）：隔离与限制
* `Namespace`技术实际上修改了应用进程看待整个计算机"视图"，即它的"视线"被操作系统做了限制，只能"看到"某些指定的内容。
* `虚拟机`和`容器`的区别
  * 虚拟机是真实存在的(需要有一套完成的GuestOS造成资源消耗约如100~200MB)，而容器只是一个宿主机上的普通进程(占用资源忽略不计)
  * 虚拟机对宿主机操作系统调用会有性能损耗(尤其是计算资源、网络和磁盘I/O)，而容器并不存在性能损耗
* 既然容器是宿主机上一个特殊进程，那么多个容器之间用的是同一个宿主机的操作系统内核(共享内核导致隔离不彻底)
* `Cgroups`全称是`Control Group`，用来限制一个进程组能够使用的资源上限，包括CPU、内存、磁盘、网络带宽等等
* 容器是一个"单进程"模型


* 小结
  * `虚拟机`需要借助`GuestOS`才能运行应用，`容器`实际上就是OS的进程，一组文件和运行环境，更加简单。
  * 虚拟化较容器化有更大的资源损耗
  * 容器相较于虚拟机最大的优势是`敏捷`和`高性能`
  * 多个容器共享内核导致隔离不彻底所以引入了`Cgroups`限制资源
  * 具体`Cgroups`相关指令操作参考相关文档...
  * 一个正在运行的docker容器，其实就是启用了多个`Namespace`的应用进程，而这个进程能够使用的资源量，则受Cgroups配置的限制
  * `Cgroups`问题：如果在容器中执行top指令，将会显示宿主机的CPU和内存数据，而不是当前容器的数据(原因是/proc文件系统并不知道用户通过`Cgroups`对这个容器做了怎样的资源限制)
    * lxcfs可解决该问题
  
  
  
  
